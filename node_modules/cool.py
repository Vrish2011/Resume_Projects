import subprocess
import sys
from pathlib import Path

REMOTE = "my_url"   # change if your remote name is different (e.g., "origin")
BRANCH = "main"     # change if needed

def run(cmd: list[str], cwd: str | None = None) -> str:
    """Run a command, show it, return stdout. Exit on failure with stderr shown."""
    print("\n$", " ".join(cmd))
    p = subprocess.run(
        cmd,
        cwd=cwd,
        text=True,
        capture_output=True
    )
    if p.stdout.strip():
        print(p.stdout)
    if p.returncode != 0:
        if p.stderr.strip():
            print(p.stderr, file=sys.stderr)
        sys.exit(p.returncode)
    return p.stdout

def main():
    # Optional: set cwd to the script's folder
    repo_dir = Path.cwd()

    # 1) Verify we're inside a git repo
    run(["git", "rev-parse", "--is-inside-work-tree"], cwd=str(repo_dir))

    # 2) Show remotes (debug)
    run(["git", "remote", "-v"], cwd=str(repo_dir))

    # 3) Ensure remote exists
    remotes = run(["git", "remote"], cwd=str(repo_dir)).split()
    if REMOTE not in remotes:
        print(f"\nRemote '{REMOTE}' not found. Add it like this:")
        print(f"git remote add {REMOTE} https://github.com/<user>/<repo>.git")
        sys.exit(1)

    # 4) Pull with rebase from remote branch
    run(["git", "pull", "--rebase", REMOTE, BRANCH], cwd=str(repo_dir))

    # 5) Push back up
    run(["git", "push", REMOTE, BRANCH], cwd=str(repo_dir))

    print("\nâœ… Done: rebased and pushed successfully.")

if __name__ == "__main__":
    main()
